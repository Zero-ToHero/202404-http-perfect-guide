청크 인코딩(chunked encoding)은 HTTP/1.1에서 지원하는 데이터 전송 방식으로, 데이터의 전체 크기를 미리 알 수 없는 경우 유용하게 사용된다.

- **데이터 분할**: 서버는 전송할 데이터를 여러 청크로 나눕니다. 각 청크는 독립적으로 전송되며, 청크 크기와 데이터로 구성.
- **청크 헤더**: 각 청크의 앞에는 해당 청크의 크기를 16진수로 나타낸 청크 헤더가 붙음. 예를 들어, 4바이트의 데이터 청크가 있다면 "4\r\n"이 청크 데이터 앞에 추가된다
- **청크 데이터**: 청크 헤더 다음에는 실제 데이터가 위치하며, 청크의 끝에는 "\r\n"이 추가된다.
- **최종 청크**: 모든 데이터 청크가 전송된 후, 크기가 0인 최종 청크("0\r\n\r\n")를 전송하여 데이터 전송의 끝을 알림.

```jsx
headers = {
    "Content-Type": "text/plain",
    "Transfer-Encoding": "chunked"
}
```

**Wikipedia in chunks**

```jsx
4\r\n
Wiki\r\n
5\r\n
pedia\r\n
E\r\n
 in\r\n
chunks.\r\n
0\r\n
\r\n
```

- **첫 번째 청크**:
    - 크기: 4 ("4\r\n")
    - 데이터: "Wiki"
    - 끝: "\r\n"
- **두 번째 청크**:
    - 크기: 5 ("5\r\n")
    - 데이터: "pedia"
    - 끝: "\r\n"
- **세 번째 청크**:
    - 크기: E (16진수 14, "E\r\n")
    - 데이터: " in\r\nchunks."
    - 끝: "\r\n"
- **최종 청크**:
    - 크기: 0 ("0\r\n")
    - 끝: "\r\n"

**장점**

- 실시간 데이터 전송
- 메모리 효율성
- 전송 시간 단축

단점

- 복잡성 증가
- 오버헤드
- 연결 유지 필요
- 프록시와 캐시 문제

---

### Linux(유닉스 계열)

리눅스에서는 줄바꿈을 `LF`가 기본값이다. (\n)

### Windows

Windows에서는 줄바꿈을 `CRLF`이 기본값이다.(\r\n)