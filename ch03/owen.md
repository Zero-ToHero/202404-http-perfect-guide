# HTTP 메시지
# Overview

HTTP가 인터넷의 배달원이라면 HTTP 메시지는 무언가를 담아 보내는 소포와 같다.

# 메시지의 흐름

HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록들이다. 이 메시지는 `클라이언트` , `서버` , `프록시` 사이를 흐른다.

## 메시지는 원 서버 방향을 인바운드로 하여 송신된다

HTTP 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용한다. 메시지가 원 서버로 향하는 것은 `인바운드` 로 이동하는 것이며, 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것은 `아웃바운드` 로 이동하는 것이다.

## 다운스트림으로 흐르는 메시지

요청 메시지냐 응답 메시지냐에 관계없이 모든 메시지는 `다운스트림` 으로 흐른다.  메시지 발송자는 수신자의 `업스트림` 이다.

# 메시지의 각 부분

HTTP 메시지는 단순한, 데이터의 구조화된 블록이다. 각 메시지는 클라이언트로부터의 요청이나 서버로부터의 응답 중 하나를 포함한다. 메시지는 `시작줄` `헤더 블록` `본문` 이렇게 세 부분으로 이루어 진다.

시작줄은 어떤 메시지인지를 서술하며, 헤더 블록은 속성을, 본문은 데이터를 담고 있으며, 아이에 없을 수도 있다.

## 메시지 문법

모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류되며, 요청 메시지는 웹 서버에 어떤 동작을 요구한다. 또한 응답 메시지는 요청의 결과를 클라이언트에게 돌려준다.(기본적으로 구조가 같다.)

```html
[요청 메시지 형식]
<메서드> <요청 URL> <버전>
<헤더>

<Entity 본문>

[응답 메시지 형식]
<버전> <상태코드> <,유 구절>
<헤더>

<Entity 본문>
```

### 메서드

클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작(GET, HEAD, POST 와같은 단어)

### 요청 URL

요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성요소.

### 버전

이 메시지에서 사용중인 HTTP의 버전이다.

```html
HTTP/<Maijor>.<Minor>
```

### 상태코드

요ㅛ청 중에 무엇이 일어났는지 설명하는 세 자리의 숫자이다. 각 코드의 첫 번째 자릿 수는 상태의 일반적인 분류(성공, 에러)를 나타낸다.

### 사유구절

숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구이다.

### 헤더들

이 헤더의 목록은 빈 줄(CRLF)로 끝나 헤더 목록의 끝과 Entity 본문의 시작을 표시한다.

### Entity 본문

본문은 임의의 데이터 블록을 포함한다. 모든 메시지가 본문을 갖는 것은 아니므로, 때때로 메시지는 그냥 CRLF로 끝나게 된다.

## 시작줄

모든 HTTP 메시지는 시작줄로 시작한다. 요청 메시지의 시작줄은 무엇을 해야하는지, 응답 메시지의 시작줄은 무슨 일이 일어났는지 말해준다.

### 요청줄

요청 메시지는 서버에게 리소스에 대해 무언가를 해달라고 부탁한다. 보통 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메서드와 그 동작에 대한 대상을 지칭하는 요청 URL이 들어있다.

### 응답줄

응답 메시지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다. 응답 메시지의 시작줄 혹은 응답줄에는 응답 메시지에서 쓰인 HTTP의 버전, 숫자로 된 상태 코드, 수행 상태에 대해 설명해주는 텍스트로 된 구절이 들어있다.

### 메서드

요청의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야 하는지 말해준다. 다만 모든 서버가 모든 메소드를 구현하고 있지는 않다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c77a2c20-9831-4c8a-9134-2d59b9750ec2/7c2f5ebb-f7c9-4203-b5a6-e41d69cc616b/Untitled.png)

### 상태코드

메서드가 서버에게 무엇을 해야 하는지 말해주는 것처럼, 상태 코드는 클라이언트에게 무엇이 일어났는지 말해준다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c77a2c20-9831-4c8a-9134-2d59b9750ec2/a5cca722-71ce-470b-b712-1afa2111c639/Untitled.png)

### 사유구절

사유 구절은 응답 시작줄의 마지막 구성요소다. 이는 상태 코드에 대한 글로 된 설명을 제공한다.

### 버전번호

버전 번호는 HTTP/x.y 형식으로 요청과 응답 메시지 양쪽 모두에 기술된다.

## 헤더

Http 헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다. 기본적으로 이름/값 쌍의 목록이다.

### 일반 헤더

요청과 응답 양쪽에 모두 나타날 수 있음

### 요청 헤더

요청에 대한 부가 정보를 제공

### 응답 헤더

응답에 대한 부가 정보를 제공

### Entity 헤더

본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술

### 확장 헤더

명세에 정의되지 않은 새로운 헤더

### 헤더를 여러 줄로 나누기

긴 헤더 줄은 그들을 여러 줄로 쪼개서 더 읽기 좋게 만들 수 있는데, 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭 문자가 와야 한다.

## 버전 0.9 메시지

초기의 프로토콜 버전으로 요청은 그저 메서드와 요청 URL를 갖고 있을 뿐이며, 응답은 오직 Entity로만 되어 있다. 버전 정보도 없고 상태 코드나 사유 규절도 없으며, 헤더도 포함되어 있지 않다.

이런 지나친 단순함으로 다양한 상황에 대응할 수 없다.

## 메서드

모든 서버가 모든 메서드를 구현하지 않는것에 주의해야 한다.  DELETE와 PUT과 같은 메서드의 경우 일반적으로 서버 설정에 의해 정해지며, 따라서 사이트마다 또 서버마다 다를 수 있다.

### 안전한 메서드

GET과 HEAD 메서드는 안전하다고 할 수 있는데, 이는 GET이나 HEAD 메서드를 사용하는 HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미한다.

작용이 없다는 것은, HTTP 요청의 결과로 인해 서버에서 일어나는 일은 아무것도 없다는 의미이다.

### GET

가장 흔히 쓰이는 메서드로 주로 서버에게 리소스를 달라고 요청하기 위해 쓰인다.

### HEAD

GET처럼 동작하지만, 서버는 응답으로 헤더만을 돌려준다. Entity 본문은 결코 반환되지 않는다. 이는 클라이언트가 리소스를 실제로 가져올 필요 없이 헤더만을 조사할 수 있도록 해준다.

- 리소스를 가져오지 않고도 그에 대해 타입등을 알아낼 수 있다.
- 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
- 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.

### PUT

PUT 메서드는 서버에 문서를 쓴다. 이는 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것이다.

### POST

POST 메서드는 서버에 입력 데이터를 전송하기 위해 설계 되었다. 데이터는 서버로 전송되며 서버는 이를 모아서 필요로 하는 곳에 보낸다.

### TRACE

클라이언트가 자산의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다. TRACE 메서드는 주로 진단을 위해 사용되며 예를 들어 요청이 의도한 요청.응답 연쇄를 거쳐가는지 검사할 수 있다. 또한 프록시나 다른 애플리케이션들이 요청에 어떤 영향을 미치는지 확인해보고자 할 때도 좋은 도구다

### OPTIONS

OPTIONS 메서드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다. 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다.

### DELETE

말 그대로 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다.

### 확장 메서드

확장 메서드는 HTTP/1.1 명세에 정의되지 않은 메서드다. 이들은 서버가 관리하는 리소스에 대한 능력을 확장하는 수단을 제공한다.

## 상태코드

상태 코드는 클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공한다.

### 클라이언트와 100 Continue

만일 클라이언트가 Entity를 서버에 보내려 하고, 그전에 100 Continue 응답을 기다리겠다면, 클라이언트는 값을 100-continue로 하는 Expect 요청 헤더를 보낼 필요가 있다. 만일 아니라면 해당 헤더를 보내지 않아야 하며 이는 클라이언트가 Entity를 보낼 것이라고 생각하게 만들어 서버를 혼란에 빠뜨릴 뿐이기 때문이다.

Expect 헤더를 보낸 클라이언트는 100 Continue응답을 기다리지 않고 Entity를 보내야하며 막연히 기다리기만 해서는 안된다. 또한 사실 클라이언트 개발자는 예상하지 못한 100Continue 응답에도 대비해야 한다.

### 서버와 100 Continue

만일 서버가 100-continue 값이 담긴 Expect 헤더가 포함된 요청을 받는다면, 100 Continue 응답 혹은 에러 코드로 답해야 한다. 서버는 해당 응답을 받을 것을 의도하지 않은 클라이언트에게 해당 상태코드를 보내서는 안된다.

만일 서버가 100 Continue 응답을 보낼 기회를 갖기 전에 Entity를 수신했다면, 서버는 해당 코드를 보낼 필요가 없다. (클라이언트가 이미 계속 전송하기로 결정했기 때문) 그러나 해당 요청을 다 읽은 후에는 그 요청에 대한 최종 응답을 보내야 한다.

또한 만일 서버가 100 Continue 응답을 받을 것을 의도한 요청을 받고 난 상태에서 본문을 읽기 전에 요청을 끝내기로 결정했다면, 서버는 그냥 응답을 보내고 연결을 닫아서는 안된다. 클라이언트가 응답을 받을  수 없게 되기 떄문이다.

### 프록시와 100 Continue

만읽 프록시 서버가 해당 요청을 받는다면 다음 홉 서버에 따라 응답이 달라진다. 만일 어떤 버전을 따를지 모르거나 1.1을 따른다면 Expect헤더를 포함시켜 요청을 하며, 만일 이전 버전이라면 417Exception Faild 에러로 응답해야 한다.

만일 프록시가 1.0 혹은 이전 버전을 따르는 클라이언트를 대신해 Expect 헤더와 100 Continue 값을 요청에 포함시킨 다면 100 Continue 응답을 클라이언트에 전달해서는 안된다. 이유는 클라이언트는 어떻게 처리할지 모르기 때문이다.

프록시가 다음 홉 서버들에 대한 상태 몇 가지와 HTTP 버전을 기억해 둔다면 이는 이득이된다.

### 200-2999 성공 상태 코드

클라이언트가 요청을 보내면, 그 요청은 대개 성공하며, 서버는 대응하는 성공을 의미하는 상태 코드의 배열을 갖고 있다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c77a2c20-9831-4c8a-9134-2d59b9750ec2/99e233cb-d7de-4fac-bd5c-5a58316f3f5d/Untitled.png)

### 300-399 리다이렉션 상태코드

리다이렉션 상태 코드는 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공한다.

만약 리소스가 옮겨졌다면, 클라이언트에게 리소스가 옮겨졌으며 어디서 찾을 수 있는지 알려주기 위해 리다이렉션 상태 코드와 Location 헤더를 보낼 수 있다.(브라우저가 알아서 이동함)

일반적으로, HEAD가 아닌 요청에 대해 리다이렉션 상태 코드를 포함한 응답을 할 때, 리다이렉트될 URL에 대한 링크와 설명을 포함시키는 것은 좋은 습관이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c77a2c20-9831-4c8a-9134-2d59b9750ec2/333908ea-a42d-40e7-95e4-af12dca193e0/Untitled.png)

### 400 - 499 클라이언트 에러 상태 코드

가끔 클라이언트는 서버가 다룰 수 없는 무엇인가를 보낸다. 잘못 구성된 요청 메시지 같은 것이 있을 수 있으며, 가장 흔한 것은 존재하지 않는 URL에 대한 요청이다.

[400 Bad Request - HTTP | MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/400)

### 500 - 599 서버 에러 상태 코드

때때로, 클라이언트가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생하는 경우가 있다. 이것은 클라이언트가 서버의 제한에 걸린 것일 수 도 있고 혹은 게이트웨이 리소스와 같은 서버의 보조 구성요소에서 발생한 에러일 수도 있다.

[500 Internal Server Error - HTTP | MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/500)

# 헤더

헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용된다. 헤더에는 특정 종류의 메시지에만 사용할 수 있는 헤더와, 더 일반 목적으로 사용할 수 있는 헤더, 그리고 응답과 요청 메시지 양쪽 모두에 정보를 제공하는 헤더가 있다.

### 일반헤더

일반 헤더는 클라이언트와 서버 양쪽 모두가 사용한다. 이들은 클라이언트, 서버, 그리고 어딘가에 메시지를 보내는 다른 애플리케이션들을 위해 다양한 목적으로 사용된다.(Ex Date 헤더)

### 요청 헤더

이름에서 드러나는 것과 같이, 요청 헤더는 요청 메시지를 위한 헤더다. 그들은 서버에게 클라이언트가 받고자 하는 데이터의 타입이 무엇인지와 같은 부가 정보를 제공한다.(ex Accept 헤더)

### 응답헤더

응답 메시지는 클라이언트에게 정보를 제공하기 위한 자신만의 헤더를 갖고 있다.

### Entity헤더

본문에 대한 헤더를 의미하며 Content-Type과 같은 헤더를 통해 본문에 들어있는 데이터의 타입이 무엇인지 말해준다.

### 확장헤더

확장 헤더는 애플리케이션 개발자들에 의해 만들어졌지만 아직 승인된 HTTP 명세에는 추가되지 않은 비표준 헤더다. HTTP 프로그램은 확장 헤더들에 대해 설령 그 의미를 모른다 할지라도 용인하고 전달해야 할 필요가 있다.

## 일반 헤더

어떤 헤더는 메시지에 대한 아주 기본적인 정보를 제공하며 이 헤더들은 일반 헤더라고 불린다. 메시지가 어떤 종류이든 상관없이 유용한 정보를 제공하며, 예를 들어, 요청에서나 응답에서나 메시지가 생성된 일시는 같은 의미를 가지므로, 이런 종류의 정보를 제공하는 헤더는 양쪽 메시지 모두에 대해 일반적이다.

## 요청 헤더

요청 헤더는 요청 메시지에서만 의미를 갖는 헤더로, 누가 혹은 무엇이 그 요청을 보냈는지에 대한 정보나 클라이언트의 선호나 능력에 대한 정보를 준다.

### Accept 관련 헤더

클라이언트는 Accept 관련 헤더들을 이용해 서버에게 자신의 선호와 능력을 알려줄 수  있다. 즉 클라이언트가 무엇을 원하고 무엇을 할 수 있는지, 그리고 무엇보다도 원치 않는 것은 무엇인지 알려줄 수 있다.

### 조건부 요청 헤더

클라이언트가 이미 어떤 문서의 사본을 갖고 있는 상태라면, 클라이언트는 서버에게 그 문서를 요청할 때 자신이 갖고 있는 사본과 다를 때만 전송해 달라고 요청하고 싶을 수  있을 것이다. 조건부 요청 헤더를 사용하면, 클라이언트는 서버에게 요청에 응답하기 전에 먼저 조건이 참인지 확인하는 제약을 포함시킬 수 있다.

### 요청 보안 헤더

HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 갖고 있다. 그것은 요청하는 클라이언트가 어느 정도의 리소스에 접근하기 전에 자신을 인증하게 함으로써 트랜잭션을 약간 더 안전하게 만들고자 한다.

## 응답 헤더

응답 헤더는 클라이언트에게 부가 정보를 제공한다. 누가 응답을 보내고 있는지 혹은 응답자의 능력은 어떻게 되는지 알려주며, 더 나아가 응답에 대한 특별한 설명도 제공할 수 있다.

### 협상 헤더

서버에 프랑스어와 독일어로 번역된 HTML문서가 있는 경우와 같이 여러 가지 표현이 가능한 상황이라면 클라이언트가 어떤 표현을 선택할 것인가에 대한 협상을 할 수 있도록 지원한다.

### 응답 보안 헤더

Set-Cookie 등 서버가 클라이언트를 인증할수 있도록 클라이언트 측에 토큰을 서정하기 위해 사용하는 경우가 있다.

## Entity 헤더

요청과 응답 양쪽 모두 Entity를 포함할 수 있기 때문에, 이 헤더들은 양 타입의 메시지에 모두 나타날 수 있다.

엔티티 헤더는 엔티티와 내용물에 대한, 개체의 타입부터 시작해 주어진 리소스에 대해 요청할 수 있는 유효한 메서드들까지 광범위한 정보를 제공한다,

### 콘텐츠 헤더

콘텐츠 헤더는 엔터티의 콘텐츠에 대한 구체적인 정보를 제공한다. 콘텐츠의 종류, 크기, 기타 콘텐츠를 저리할 때 유용하게 활용될 수 있다.(ex Content-Type)

### 캐싱헤더

엔터티 캐싱에 대한 정보를 제공한다. 예를 들면 리소스에 대해 캐시된 사본이 아직 유효한지에 대한 정보와,  리소스가 더 이상 유효하지 않게 되는 시점을 더 잘 추정하기 위한 단서 같은 것이다.
