## 커넥션 관리

> 요약
- HTTP는 어떻게 TCP 커넥션을 사용하는가
- TCP 커넥션의 지연, 병목, 막힘
- 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화
- 커넥션 관리를 위해 따라야할 규칙들

### TCP 커넥션
- HTTP 통신은 ~패킷 교환 네트워크 프로토콜~들의 계층화된 집합인 `TCP/IP`를 통해 이루어진다.
- 커넥션이 일반 맺어지면, 클라-서버 간에 주고받는 메시지들은 `손실/손상`없이 `순서 바뀜`없이 안전하게 전달된다.

> 단계
1. 브라우저가 호스트명 추출
2. DNS와의 통신으로 IP주소를 찾는다.
3. 브라우저가 포트 번호를 얻는다.
4. IP주소 + 포트 경로로 TCP 커넥션을 생성한다.
5. 브라우저가 서버로 HTTP GET 요청 메시지를 보낸다.
6. 응답 메시지를 받는다.
7. 브라우저가 커넥션을 끊는다.

#### 신뢰할 수 있는 데이터 전송 통로인 TCP
- 클라 -> 서버로 순서에 맞게 정확히 전달.
#### TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.
- TCP는 패킷이라고 불리는 작은 조각을 통해 데이터를 전송함.
- 세그먼트라는 단위로 데이터 스트림을 잘게 나누고, 패킷이라고 하는 봉투에 담아서 인터넷(Internet layer)을 통해보낸다.

```
IP 패킷 헤더(보통 20bytes)
TCP 세그먼트 헤더(보통 20bytes)
TCP 데이터 조각(0 or 그 이상)
```

- IP 헤더는 `발신지 & 목적지 IP`, `크기`, `기타 플래그`를 가진다.
- TCP 세그먼트 헤더는 `TCP 포트번호`, `TCP 제어 플래그`, 데이터의 순서와 무결성을 검사하기 위해 필요한 숫자(인덱스)를 포함한다.
#### TCP 커넥션 유지하기
- 컴퓨터는 항상 TCP 커넥션을 여러개 가지고 있다.
- 포트번호를 통해서 여러개의 커넥션 유지
- IP주소는 해당 컴퓨터에 연결
- 포트번호는 해당 애플리케이션에 연결
- 아래 네가지 요소로 유일한 커넥션 생성

```
1. 발신지 IP
2. 발신지 포트
3. 수신지 IP
4. 수신지 포트
```

### TCP 성능에 대한 고려
- HTTP는 TCP바로 위의 계층이기에 TCP 성능에 영향을 받음

#### HTTP 트랜잭션 지연
- HTTP 통신에 비해 TCP 커넥션 설정 시간이 매우 길다.
- 대부분 TCP 커넥션 지연때문에 HTTP가 지연된다.
- 지연의 원인
```
1. DNS 통해서 호스트명을 IP주소로 변환하는 시간
2. 여러개의 TCP 커넥션 존재시 크게 증가하는 응답시간
3. 데이터가 도착하는대로 요청 처리 -> 인터넷 통해서 전달되고 서버에 의해서 처리되는 시간 소요
4. 웹 서버의 HTTP 응답시간
```

#### 성능 관련 중요 요소
- TCP 연결의 handshake
- 인터넷 혼잡 제어를 위한 slow-start
- 데이터 모아서 전송하기 위한 nagle 알고리즘
  - 가능한 모아서 더 큰 패킷으로 한번에 보내는 방법
- TCP piggyback acknowledgement 를 위한 확인응답 지연 알고리즘
  ![](image.png)
- 타임아웃 or 포트고갈

#### TCP 커넥션 handshake 지연
- 클라는 새로운 TCP를 생성하기 위해 작은 패킷을 서버에 전송
  - *[클라->서버]* SYN 플래그 (`커넥션 생성 요청`)
  - *[서버->클라]* SYN + ACK 플래그 (`요청 받았어`)
  - *[클라->서버]* ACK (`커넥션이 잘 맺어졌어`)

#### 확인응답 지연
- TCP는 송출 데이터 패킷과 확인응답을 하나로 묶어서 네트워크를 더 효율적으로 사용

#### TCP 느린 시작(slow start)
- 처음에는 최대 속도를 제한
- 데이터 전송이 성공하면 차차 속도 제한 높임
- (`혼잡 제어`) 갑작스러운 부하와 혼잡 방지
- (`혼잡 제어`) 한번에 전송할 수 있는 패킷 수 제한
- 혼잡 제어 기능 때문에 느려짐

#### 네이글(Nagle) 알고리즘
- 세그먼트가 최대 크기가 되지 않으면 전송하지 않음.
- 모든 패킷이 확인 응답을 받았을 경우, 최대 크기보다 작은 패킷의 전송 허용
- 크기가 작은 HTTP 메시지는 패킷을 채우지 못함.

#### TIME_WAIT 누적, 포트 고갈
- TCP 커넥션을 끊으면, 종단에서는 커넥션의 IP주소와 포트번호를 메모리의 한 영역에 기록해둔다.
- 이 기록이 유지되는 동안 동일한 주소, 포트번호가 재생성되는 것을 막는다.
- 가능한 연결의 조합이 제한되며, TIME_WAIT으로 인해 사용할 수 있는 발신지 포트 고갈
- 이러한 상황에서 극심한 성능 저하가 발생한다.

### HTTP 커넥션 관리
#### 흔히 잘못 이해하는 Connection 헤더
- HTTP는 클라와 서버사이 수많은 서버들이 존재한다.
- 커넥션 토큰이 HTTP 헤더 필드명을 가지면, 해당 필드들은 현재 커넥션만을 위한 정보이다. 따라서 다음 커넥션에 전달되면 안된다.
- 따라서 Connection 헤더에 존재하는 모든 헤더 필드들을 다음 홉으로 전달하기 전에 삭제해야한다.

#### 순차적인 트랜잭션 처리에 의한 지연
- 이미지 4개를 보여주려면 4개의 HTTP 트랜잭션이 필요함.
- 각 트랜잭션이 새로운 커넥션을 필요로 한다면 커넥션 맺는 데에 발생하는 지연과 느린 시작 지연이 발생할 것이다.
  - 열려있는 커넥션은 하나
  - 연결 맺고 끊기가 4번 수행됨. (커넥션 지연이 4번 발생)-> 매우 비효율

### 병렬 커넥션
- 한번에 여러 개의 커넥션 맺고 트랜잭션을 병렬로 처리
- 각 커넥션의 지연 시간이 동시에 소요됨.
  - 지연시간 효율 증가
- 항상 빠르지는 않다.
  - 클라의 네트워크 대역폭이 좁을 때, 각 객체를 전송받는 것은 느리기 때문에 성능 이점은 거의 없어진다.
- 다수의 커넥션은 메모리 소모, 자체 성능 문제 야기
- 과도한 수의 커넥션 발생시 서버가 임의로 끊어버릴 수 있음.

### 지속 커넥션
- 처리가 완료된 이후에도 커넥션을 유지하여 앞으로의 HTTP 요청에 재사용한다.
- 커넥션 맺을 때 발생하는 지연시간이 줄어든다.
- 하지만, 계속 연결된 상태로 있는 수많은 커넥션이 쌓이면 리소스를 낭비하게 된다.
#### 지속 커넥션 vs 병렬커넥션
- 이 둘은 각기 다른 장단점이 있지만, 사용할 때 가장 효과적이다.
#### Keep-Alive 커넥션
- 몇개의 커넥션을 특정 시간동안 유지하는 방식.
```
Connection: Keep-Alive
Keep-ALive: max=5, timeout=120
```
#### Keep-Alive 커넥션 제한과 규칙
- HTTP1.0에서 기본 아님
- Keep-Alive를 사용하려면 매 요청마다 Keep-Alive헤더를 포함해야한다.
  - 없다면 서버는 요청 처리 후, 커넥션을 끊는다.
- 커넥션이 끊어지기 전에 엔터티 본문 길이를 알아야 커넥션 유지 가능
- 프록시와 게이트웨이는 메시지 전달 전 or 캐시 전달 전에 Connection 헤더에 명시된 모든 헤더 필드와 Connection 헤더를 제거해야한다.
- keep-ailve 커넥션은 Connection헤더를 인식하지 못하는 프록시 서버와 맺어져서는 안된다.
  - 이렇게 되면 connection 헤더의 내용을 다음 홉에 전송하기 때문
#### Proxy-Connection
- 모든 헤더를 무조건 전달하는 문제를 해결하기 위한 차선책
- 브라우저에서 일반적으로 전달하는 Connection 헤더 대신 비표준인 Proxy-Connection을 프록시에 전달함.

#### 지속 커넥션의 제한과 규칙
- 커넥션을 끊기 위해서는 `Connection: close` 헤더를 포함해야한다.
- 커넥션에 있는 모든 메시지가 자신의 길이 정보를 정확히 가지고 있을 때에만 커넥션 지속이 가능하다.
- 프록시 서버는 클라의 커넥션 관련 기능에 대한 지원 범위를 알고있는 경우에만 지속 커넥션을 맺어야한다.
  - 오래된 프록시가 `Connection`  헤더를 전달하는 문제가 발생할 수 있기 때문.
- HTTP1.1 프록시는 클라와 서버 각각에 대해 별도의 지속 커넥션을 맺고 관리해야한다.
- 중간에 끊어지는 커넥션을 복구할 수 있어야한다.

#### 커넥션 끊기의 허용, 재시도, 멱등성
- 동일한 동작을 여러번 반복해도 결과가 같은 특징을 `멱등성`이라고 한다.
  - POST는 비멱등, 나머지 메서드(GET, HEAD, PUT, DELETE 등)은 멱등하다.
- 클라는 POST와 같이 멱등하지 않은 요청은 파이프라인을 통해서 요청하면 안된다.
  - 에러 발생시, 추적이 어렵기 때문

#### 우아하게 커넥션 끊기
- 자신의 출력 채널을 먼저 끊고 다른 쪽에 있는 기기의 출력 채널이 끊기길 기다리는 것.
- 출력 채널에 절반 끊기를 하고, 데이터나 스트림의 끝을 식별하기 위해 입력 채널에 대한 상태 검사를 주기적으로 해야한다.
