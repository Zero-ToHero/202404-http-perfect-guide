- **TCP 커넥션**
    - 전 세계 모든 HTTP 통신은 TCP/IP를 통해 이루어진
        
        ![72061509-616db480-3319-11ea-9ee5-71a851559e5e.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9bf36ad3-0719-431a-b1e2-3f429aeb690d/efdaf99b-78b9-469b-a26d-d1f7920796cf/72061509-616db480-3319-11ea-9ee5-71a851559e5e.png)
        
- **신뢰할 수 있는 데이터 전송 통로인 TCP**
    - TCP는 HTTP에게 신뢰할 만한 통신 방법을 제공한다. TCP 커넥션의 한쪽에 있는 바이트들은 반대쪽으로 순서에 맞게 정확히 전달된다.

- **TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다**
    - TCP는 IP 패킷이라고 불리는 작은 조각을 통해 데이터를 전송한다
    - TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고, 세그먼트를 IP 패킷이라고 불리는 봉투에 담아서 인터넷을 통해 데이터를 전달한다. 이 모든 것은 TCP/IP 소프트웨어에 의해 처리된다.
        
        ![72062606-764b4780-331b-11ea-9a35-d32b3dc87570.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9bf36ad3-0719-431a-b1e2-3f429aeb690d/5d3a828f-6525-4d7e-b83e-bf57588b9521/72062606-764b4780-331b-11ea-9a35-d32b3dc87570.png)
        

- **TCP 커넥션 유지하기**
    - 컴퓨터는 항상 TCP 커넥션을 여러 개 가지고 있다. TCP는 포트 번호를 통해서 이런 여러 개의 커넥션을 유지한다. (<발신지 IP주소, 발신지 포트, 수신지 IP주소, 수신지 포트>)
    - 이 네 가지 값으로 유일한 커넥션을 생성한다. 서로 다른 두 개의 TCP 커넥션은 네 가지 주소 구성요소 값이 모두 같을 수 없다.
    
- **TCP 소켓 프로그래밍**
    - 운영체제는 TCP 커넥션의 생성과 관련된 여러 기능을 제공한다.
        
        ![72063779-cdeab280-331d-11ea-9fdb-0b2d5f1fb417.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9bf36ad3-0719-431a-b1e2-3f429aeb690d/632a18c9-444d-4741-be55-c16a3f3d69aa/72063779-cdeab280-331d-11ea-9fdb-0b2d5f1fb417.png)
        
- **TCP의 성능에 대한 고려**
    - HTTP 트랜잭션 지연
        - 클라이언트는 URI에서 웹 서버의 IP주소와 포트 번호를 알아내야 하는데, 해당 호스트에 방문한 적이 없으면 시간이 더 걸릴 것이다.
        - 클라이언트는 TCP 커넥션 요청을 서버에게 보내고 서버가 커넥션 허가 응답을 회신하기를 기다린다.
        - 커넥션이 맺어지면 클라이언트는 HTTP 요청을 새로 생성된 TCP 파이프를 통해 전송한다. 웹 서버는 데이터가 도착하는 데로 TCP 커넥션에서 요청 메시지를 읽고 처리한다. 요청 메시지가 인터넷을 통해 전달되고 서버에 의해서 처리되는 데 까지는 시간이 소요된다.
        - 웹 서버가 HTTP 응답을 보내는 것 역시 시간이 소요된다.
    - TCP 커넥션 핸드셰이크 지연
        - 어떤 데이터를 전송하든 새로운 TCP 커넥션을 열 때면, TCP 소프트웨어는 커넥션을 맺기 위한 조건을 맞추기 위해 연속으로 IP 패킷을 교환한다. 작은 크기의 데이터 전송에 커넥션이 사용된다면 이런 패킷 교환은 HTTP 성능을 크게 저하시킬 수 있다.
        - HTTP 트랜잭션이 아주 큰 데이터를 주고받지 않는 평범한 경우에는, SYN/SYN+ACK 핸드셰이크가 눈에 띄는 지연을 발생시킨다. TCP의 ACK 패킷은 HTTP 요청 메시지 전체를 전달할 수 있을 만큼 큰 경우가 많고, 많은 HTTP 서버 응답 메시지는 하나의 IP 패킷에도 담길 수 있다.
    - 확인응답 지연
        - 인터넷 자체가 패킷 전송을 완벽히 보장하지는 않기 때문에, TCP는 성공적인 데이터 전송을 보장하기 위해서 자체적인 확인 체계를 가진다.
        - 각 TCP 세그먼트는 순번과 데이터 무결성 체크섬을 가진다
        - 송신자가 특정 시간 안에 확인응답 메시지를 받지 못하면 패킷이 파기되었거나 오류가 있는 것으로 판단하고 데이터를 다시 전송한다.
        - 확인응답은 그 크기가 작기 때문에, TCP는 같은 방향으로 송출되는 데이터 패킷에 확인응답을 '편승(piggyback)' 시킨다
        - 만약 일정 시간 안에 송출 데이터 패킷을 찾지 못하면 확인응답은 별도 패킷을 만들어 전송된다
        - 해당 방향으로 송출될 패킷이 많지 않기 때문에 지연이 자주 발생한다. 지연의 원인이 되는 확인응답 지연관련 기능을 수정하거나 비활성화 할 수 있다.
    - TCP 느린 시작(slow start)
        - TCP 커넥션은 시간이 지나면서 자체적으로 '튜닝'되어서, 처음에는 커넥션의 최대 속도를 제한하고 데이터가 성공적으로 전송됨에 따라서 속도 제한을 높여나간다
        - TCP 느린 시작은 TCP가 한 번에 전송할 수 있는 패킷의 수를 제한한다. 간단히 말해 패킷이 성공적으로 전달되는 각 시점에 송신자는 추가로 2개의 패킷을 더 전송할 수 있는 권한을 얻는다(혼잡 윈도를 연다)
    - 네이글(Nagle) 알고리즘과 TCP_NODELAY
        - 네이글 알고리즘은 네트워크 효율을 위해서, 패킷을 전송하기 전에 많은 양의 TCP 데이터를 한 개의 덩어리로 합친다
        - 네이글 알고리즘은 세그먼트가 최대 크기가 되지 않으면 전송을 하지 않는다
        - 다만 다른 모든 패킷이 확인응답을 받았을 경우에는 최대 크기보다 작은 패킷의 전송을 허락한다
        - 크기가 작은 HTTP 메시지는 패킷을 채우지 못하기 때문에, 앞으로 생길지 생기지 않을지 모르는 추가적인 데이터를 기다리며 지연될 것이다.
        - 네이글 알고리즘은 확인응답 지연과 함께 쓰일 경우 형편없이 동작한다
        - HTTP 애플리케이션은 성능 향상을 위해서 HTTP 스택에 TCP_NODELAY 파라미터 값을 설정하여 네이글 알고리즘을 비활성화하기도 한다
    - TIME_WAIT의 누적과 포트 고갈
        - TIME_WAIT 포트 고갈은 성능 측정 시에 심각한 성능 저하를 발생시키지만, 보통 실제 상황에서는 문제를 발생시키지 않는다.
        - TCP 커넥션의 종단에서 TCP 커넥션을 끊으면, 종단에서는 커넥션의 IP 주소와 포트 번호를 메모리의 작은 제어영역(control block)에 기록해 놓는다
        - 특정 커넥션이 생성되고 닫힌 다음, 그와 같은 IP 주소와 포트 번호를 가지는 커넥션이 2분 이내에 또 생성되는 것을 막아준다.
        
- **HTTP 커넥션 관리**
    - **흔히 잘못 이해하는 Connection 헤더**
        - HTTP는 클라이언트와 서버 사이에 프록시 서버, 캐시 서버 등과 같은 중개 서버가 놓이는 것을 허락한다. HTTP 메시지는 클라이언트에서 서버까지 중개 서버들을 하나하나 거치면서 전달 된다.
        - 커넥션 토큰이 HTTP 헤더 필드 명을 가지고 있으면, 해당 필드들은 현재 커넥션만을 위한 정보이므로 다음 커넥션에 전달하면 안 된다. Connection 헤더에 있는 모든 헤더 필드는 메시지를 다른 곳으로 전달하는 시점에 삭제되어야 한다
        - Connection 헤더는 홉별(hop-by-hop) 헤더 명을 기술하는데, 이것을 '헤더 보호하기'라 한다
    - 순차적인 트랜잭션 처리에 의한 지연
        - 각 트랜잭션이 새로운 커넥션을 필요로 한다면, 커넥션을 맺는데 발생하는 지연과 함께 느린 시작 지연이 발생할 것이다.
            
            ![72679106-4c4e0e00-3aef-11ea-814f-be78511c73f3.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9bf36ad3-0719-431a-b1e2-3f429aeb690d/e18fe75f-ec0c-49ab-844c-d275e0544886/72679106-4c4e0e00-3aef-11ea-814f-be78511c73f3.png)
            
        - 병렬(parallel) 커넥션: 여러 개의 TCP 커넥션을 통한 동시 HTTP 요청
        - 지속(persistent) 커넥션: 커넥션을 맺고 끊는 데서 발생하는 지연을 제거하기 위한 TCP 커넥션의 재활용
        - 파이프라인(pipelined) 커넥션: 공유 TCP 커넥션을 통한 병렬 HTTP 요청
        - 다중(multiplexed) 커넥션: 요청과 응답들에 대한 중재
    
- **병렬 커넥션**
    - HTTP는 클라이언트가 여러 개의 커넥션을 맺음으로써 여러 개의 HTTP 트랜잭션을 병렬로 처리할 수 있게 한다.
    - 병렬 커넥션은 페이지를 더 빠르게 내려 받는다
    - 병렬 커넥션이 항상 더 빠르지는 않다
        - 클라이언트의 네트워크 대역폭이 좁을 때
    - 병렬 커넥션은 더 빠르게 느껴질 수 있다

- **지속 커넥션**
    - 서버에 HTTP 요청을 하기 시작한 애플리케이션은 웹페이지 내의 이미지 등을 가져오기 위해서 그 서버에 또 요청하게 될 것이다. 이 속성을 사이트 지역성(site locality)라 부른다.
    - HTTP/1.1을 지원하는 기기는 처리가 완료된 후에도 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용할 수 있다
    - 처리가 완료된 후에도 계속 연결된 상태로 있는 TCP 커넥션을 지속 커넥션이라고 부른다
    - 지속 커넥션 vs 병렬 커넥션
        - 지속 커넥션은 병렬 커넥션에 비해 몇 가지 장점이 있다. 커넥션을 맺기 위한 사전 작업과 지연을 줄여주고, 튜닝된 커넥션을 유지하며, 커넥션의 수를 줄여준다. 하지만 지속 커넥션을 잘못 관리할 경우, 계속 연결된 상태로 있는 수많은 커넥션이 쌓이게 될 것이다. 이는 로컬의 리소스 그리고 원격의 클라이언트와 서버의 리소스에 불필요한 소모를 발생시킨다.
    - HTTP/1.0+의 Keep-Alive 커넥션
        - Keep-Alive
            - 이 요청을 받은 서버는 그다음 요청도 이 커넥션을 통해 받고자 한다면, 응답 메시지에 같은 헤더를 포함시켜 응답한다. 응답에 Coneection: Keep-Alive 헤더가 없으면, 클라이언트는 서버가 keep-alive를 지원하지 않으며, 응답 메시지가 전송되고 나면 서버 커넥션을 끊을 것이라 추정한다.
            - Keep-Alive 헤더는 커넥션을 유지하기를 바라는 요청일 뿐이다. 클라이언트나 서버가 keep-avlie 요청을 받았다고 해서 무조건 그것을 따를 필요는 없다.
        - Keep-Alive 커넥션 제한과 규칙
            - keep-alive는 HTTP/1.0에서 기본으로 사용되지는 않는다
            - 커넥션을 계속 유지하려면 모든 메시지에 Connection: Keep-Alive 헤더를 포함해 보내야 한다.
            - 프락시와 게이트웨이는 Connection 헤더의 규칙을 철저히 지켜야 한다. 프락시와 게이트웨이는 메시지를 전달하거나 캐시에 넣기 전에 Connection 헤더에 명시된 모든 헤더 필드와 Connection 헤더를 제거해야 한다.
            - keep-alive 커넥션은 Connection 헤더를 인식하지 못하는 프락시 서버와는 맺어지면 안 된다
        - Keep-Alive와 멍청한(dumb) 프락시
            - 프락시는 Connection 헤더를 이해하지 못해서 해당 헤더들을 삭제하지 않고 요청 그대로를 다음 프락시에 전달한다
            - Connection 헤더 값으로 명시되지 않는, Proxy-Authenticate, Proxy-Connection, Transfer-Encoding, Upgrade와 같은 홉별 헤더들 역시 전달하거나 캐시하면 안 된다.
                
                ![76606245-4277e280-6555-11ea-84ce-7b181ea46562.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9bf36ad3-0719-431a-b1e2-3f429aeb690d/f53e9bd6-7e28-4da4-bff8-a39789444c8f/76606245-4277e280-6555-11ea-84ce-7b181ea46562.png)
                
        - Proxy-Connection 살펴보기
            - Connection 헤더 대신 비표준인 Proxy-Connection 확장 헤더를 프락시에게 전달한다. 프락시가 Proxy-Connection 헤더를 무조건 전달하더라도 웹 서버는 그것을 무시하기 때문에 별문제가 되지 않는다
            - 이 방식은 클라이언트와 서버 사이에 한 개의 프락시만 있는 경우에만 동작한다. 하지만 멍청한 프락시의 양옆에 영리한 프락시가 있다면 아래 그림과 같이 잘못된 헤더를 만들어내는 문제가 발생한다.
                
                ![76608927-dd72bb80-6559-11ea-90e8-eee4f9c9b7bb.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9bf36ad3-0719-431a-b1e2-3f429aeb690d/d84dd1b3-73ee-460c-815f-69774017fd23/76608927-dd72bb80-6559-11ea-90e8-eee4f9c9b7bb.png)
                
                ![76609221-5bcf5d80-655a-11ea-98c4-eeec99d43832.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9bf36ad3-0719-431a-b1e2-3f429aeb690d/096adf7b-e8c1-4d1f-ad93-b0918ef9d781/76609221-5bcf5d80-655a-11ea-98c4-eeec99d43832.png)
                
        - HTTP/1.1의 지속 커넥션
            - HTTP 1.1Keep-alive 커넥션을 지원하지 않는 대신 설계가 더 개선된 지속 커넥션을 지원한다.
            - HTTP 1.1 지속커넥션을 통해서 요청을 파이프라이닝할 수 있다.
        
- **우아한 커넥션 끊기**
    - 전체끊기
    - 서버 출력 절반 끊기
    - 서버 입력 절반 끊기