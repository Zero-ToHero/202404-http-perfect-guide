# 04. 커넥션 관리

## 4.1 TCP 커넥션
- 전세계 모든 HTTP 통신은 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 TCP/IP를 통해 이루어짐
- 커넥션이 맺어지면 클라이언트와 서버 컴퓨터칸에 주고받은 메세지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달됨
> **TCP 커넥션을 통한 요청 단계 예시**
> 1. 브라우저가 호스트명 추출
> 2. 브라우저가 호스트명에 대한 IP 주소 찾음
> 3. 브라우저가 포트번호 얻음
> 4. 브라우저가 IP 주소의 포트번호로 TCP 커넥션 생성(맺음)
> 5. 브라우저가 커넥션을 통해 요청 메세지를 보냄
> 6. 브라우저가 서버에서 온 HTTP 응답 메세지를 읽음
> 7. 브라우저가 커넥션을 끊음 

### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP
- TCP는 HTTP에게 신뢰할 만한 통신 방식을 제공

### 4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다
- TCP는 IP패킷(혹은 IP 데이터 그램)을 통해 데이터를 전송함
- TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고, 세그먼트를 IP 패킷에 담아서 인터넷을 통해 데이터를 전달함
- 이 모든 것은 TCP/IP 소프트웨어에 의해 처리되며, 그 과정은 프로그래머에게 보이지 않음
> 참고 링크
> [IP패킷 관련](http://www.ktword.co.kr/test/view/view.php?m_temp1=5185&id=424)

- HTTPS는 HTTP에 보안 기능을 더한 것이며, TLS 혹은 SSL이라고도 불리기도 함
> 참고 링크
> [HTTPS와 HTTP 차이 1](https://www.cloudflare.com/ko-kr/learning/ssl/why-is-http-not-secure/)
> [HTTPS와 HTTP 차이 2](https://blog.wishket.com/http-vs-https-%EC%B0%A8%EC%9D%B4-%EC%95%8C%EB%A9%B4-%EC%82%AC%EC%9D%B4%ED%8A%B8%EC%9D%98-%EB%A0%88%EB%B2%A8%EC%9D%B4-%EB%B3%B4%EC%9D%B8%EB%8B%A4/)

### 4.1.3 커넥션 유지하기
- IP주소는 해당 컴퓨터에 연결되고 포트 번호는 해당 애플리케이션으로 연결됨
- TCP 커넥션을 식별할 수 있는 4가지 값
    1. 발신자 IP주소
    2. 발신자 포트
    3. 수신자 IP 주소
    4. 수진자 포트 

### 4.1.4 소켓 프로그래밍
- 운영체제는 TCP 커넥션의 생성과 관련된 여러 기능을 제공
- 소켓 API는 유닉스 운영체제용으로 먼저 개발되었지만, 지금은 대부분의 운영체제와 프로그램 언어에서 사용할 수 있음 
- 소켓 API를 사용하면 TCP endpoint 데이터 구조를 생성하고, 원격 서버의 TCP endpoint에 생성한 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있음
- TCP API는 기본적인 네트워크 프로토콜의 핸드셰이킹, TCP 데이터 스트림과 IP 패킷 간의 분할 재조립에 대한 모든 세부사항을 외부로부터 숨김

<br>

## 4.2 TCP의 성능에 대한 고려
- HTTP 트랜젝션의 성능은 아래 그 아래 계층인 TCP 성능에 영향을 받음

### 4.2.1 HTTP 트랜잭션 지연
- 클라이언트나 서버가 너무 많은 데이터를내려받거나 복잡하고 동적인 자원들을 실행하지 않는 한, 대부분의 HTTP 지연은 TCP 네트워크 지원 때문에 발생함
- TCP 네트워크 지연은 하드웨어 성능, 네트워크와 서버의 전송 속도 요청과 응답 메세지 크기, 클라이언트와 서버간의 거리, TCP 프로토콜의 기술적인 복잡성도 지연에 큰 영향을 끼침
- 지연 시키는 원인
    1. 호스트 명 -> IP 주소로 변환
    2. 커넥션 설정 시간
    3. 요청 메세지 전달 및 처리
    4. 웹 서버의 HTTP 응답 

### 4.2.2 성능 관련 중요 요소
- 프로그래머에게 영향을 주는 가장 일반적인 TCP 관련 지연들
    1. TCP 커넥션의 핸드셰이크 설정
    2. 인터넷의 혼잡을 제어하기 위한 TCP의 느린 시작(slow-start)
    3. 데이터를 한데 모아 한 번에 전송하기 위한 네이글(nagle) 알고리즘
    4. TCP의 편승(piggyback) 확인응답(acknowledgment)을 위한 확인응답 지연 알고리즘
    5. TIME_WAIT 지연과 포트 고갈

### 4.2.3 TCP 커넥션 핸드셰이크 지연
- 핸드셰이크 순서
    1. 클라이언트가 `SYN`이라는 특별한 플래그를 가지는 TCP 패킷을 서버에게 보냄 (커넥션 생성 요청)
    2. 서버가 커넥션을 받으면 `SYN`과 `ACK`플래그를 포함한 TCP 패킷을 클라이언트에게 보냄
    3. 커넥션이 잘 맺어졌음을 알리기 위해 확인 응답 신호를 보냄
- `SYN` 및 `SYN+ACK` 전달할 때 지연 발생

### 4.2.4 확인 응답 지연
- TCP 세그먼트는 순번과 데이터 무결성 체크섬을 가짐
- 세그먼트의 수신자는 세그먼트를 온전히 받으면 작은 확인 응답 패키지를 송신자에게 반환하는데, 이 때 특정 시간안에 받지 못하면 패킷이 파기되었거나 오류가 있는 것으로 판단하고 데이터를 다시 전송함
- 데이터 패킷에 편승되는 경우를 늘리기 위해 확인 응답 알고리즘을 사용하는데 이것으로 인한 지연 발생
- 확인 응답 지연은 송출할 확인응답을 특정 시간 동안 버퍼에 저장해두고, 확인응답을 편승(piggyback)시키기 위한 송출 데이터 패킷을 찾음
- 송출 데이터 패킷을 찾이 못하면 확인응답은 별도의 패킷을 만들어 전송됨
- 확인응답 지연 관련 기능을 수정하거나 비활성할 수 있음

### 4.2.5 TCP 느린 시작
- 느린 시작: 처음에는 커넥션의 최대속도를 제한하다가 데이터가 성공적으로 전송되면 속도 제한을 높여가는 것
- 인터넷의 급작스러운 부하와 혼잡을 방지하는데 쓰임


### 4.2.6 네이글 알고리즘과 TCP_NODELAY
- 네이글 알고리즘: 네트워크 효율을 위해서 패킷을 전송하기 전에 많은 양의 TCP 데이터를 한개의 덩어리로 합치는 것
- 네이글 알고리즘 문제점
    - 크기가 작은 HTTP 메세지는 패킷을 채우지 못하기 때문에 추가적인 데이터를 기다리며 지연될 수 있음
    - 확인응답 지연과 함께 쓰일 경우 형편없이 동작함
- TCP_NODELAY 파라미터 값을 설정하면 비활성할 수 있음

### 4.2.7 TIME_WAIT의 누적과 포트 고갈
- TCP 커넥션을 끊으면, 종단에서는 커넥션의 IP 주소와 포트 번호를 메모리의 작은 제어영역(control block)에 기록해둠 (커넥션 종료 지연)
이 정보는 같은 주소와 포트 번호를 사용하는 새로운 TCP 커넥션이 일정 시간 동안 생성되지 않게 하기 위한 것으로, 이 시간을 TIME_WAIT라고 함
(보통 세그먼트의 최대 생명주기의 두 배 정도로 설정되며 2분 정도, 2MSL)

<br>

## 4.3 커넥션 관리

### 4.3.1 흔히 잘못 이해하는 Connection 헤더
- HTTP Connection 헤더 필드는 커넥션 토큰을 쉼표로 구분하여 가지고 있으며, 그 값들은 다른 커넥션에 전달되지 않음
- Connection 헤더에 전달될 수 있는 세가지 종류의 토큰
    1. HTTP 헤더 필드명: 이 커넥션에만 해당되는 헤더들을 나열함, 다음 커넥션에 전달하면 안되며 메세지를 다른 곳으로 전달하는 시점에 삭제되어야 함
    2. 임시적인 토큰 값: 커넥션에 대한 비표준 옵션을 의미
    3. close 값: 커넥션 작업이 완료되면 종료되어야 함을 의미함
- 헤더 보호하기: Connection 헤더에 홉별(hop-by-hop) 헤더 기술하는 것으로 Connection 헤더에 명시된 헤더들이 전달되는 것을 방지함

### 4.3.2 순차적인 트랜잭션 처리에 의한 지연
- 순차적인 처리로 인한 지연에는 물리적인 지연뿐만 아니라, 웹페이지의 나머지 공간에 아무런 변화가 없어서 느껴지는 심리적인 지연도 있음


<br>

## 4.4 병렬 커넥션
- 병렬 커넥션: 여러개의 TCP 커넥션을 통한 동시 HTTP 요청

### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다
- 리소스를 병렬로 내려받아 커넥션 지연이 겹쳐짐으로써 총 지연시간이 줄어듬

### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다
- 병렬 커넥션이 일반적으로 더 빠르기는 하지만, 클라이언트의 네트워크 대역폭이 좁을 때는(제한된 대역 폭 내에서 각 객체를 전송받을 때) 성능상 장점이 거의 없어짐

### 4.4.3 병렬 커넥션은 더 빠르게 느껴질 수 있다
- 병렬 커넥션이 페이지를 항상 더 빠르게 로드하지는 않음
- 실제로 페이지를 더 빠르게 내려받는 것은 아니지만, 화면에 여러 개의 객체가 동시에 보이면서 빠르다고 느껴질 수 있음

<br>

## 4.4 지속 커넥션
- 지속 커넥션: 커넥션을 맺고 끊는 데서 발생하는 지연을 제거하기 위한 TCP 커넥션의 재활용

### 4.5.1 지속 커넥션 vs 병렬 커넥션
- 병렬 커넥션 단점
    1. 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소요됨
    2. 각각의 새로운 커넥션은 TCP 느린 시작 때문에 성능이 떨어짐
    3. 실제로 연결할 수 있는 병렬 커넥션의 수에는 제한이 있음
- 지속 커넥션 장점
    1. 커넥션을 맺기 위한 사전작업과 지연 줄여줌
    2. 튜닝된 커넥션을 유지하면서 커넥션의 수를 줄여줌
- 지속 커넥션 단점
    1. 잘못 관리할 경우, 계속 연결된 상태로 있는 수많은 커넥션이 쌓일 수 있음 => 로컬의 리소스의 원격의 클라이언트와 서버의 리소스에 불필요한 소모 발생
- 지속 커넥션과 병렬 커넥션은 함께 사용될 때 가장 효과적

### 4.5.2 HTTP/1.0+의 Keep-Alive 커넥션
- Keep-Alive: 커넥션을 유지할 수 있게 해주는 요청
- Keep-Alive 커넥션의 성능상 장점: 커넥션을 맺고 끊는데 필요한 작업이 없어서 연속적으로 생성하는 것보다 시간을 단축시킬 수 있음

### 4.5.3 Keep-Alive 동작
- 커넥션을 유지하기 위해 요청에 Conntection:Keep-Alive 헤더를 포함시킴
- 이 요청을 받은 서버는 응답 메세지에 같은 헤더를 포함시켜 응답함 
- 이때 응답 메세지에 Conntection:Keep-Alive 헤더가 없으면 클라이언트는 서버가 Keep-Alive를 지원하지 않으며, 응답 후 서버 커넥션을 끊을 것이라고 추정함

### 4.5.4 Keep-Alive 옵션
- timeout: 커넥션이 얼마간 유지될 것인지 지정하는 옵션
- max: 커넥션이 몇개의 HTTP 트랜잭션을 처리할 때까지 유지될 것인지 지정하는 옵션
- 그러나 옵션을 지정해도 이대로 동작한다는 보장은 없음

### 4.5.5 Keep-Alive 커넥션 제한과 규칙
- HTTP/1.0에서는 기본적으로 사용되지 않아 별도로 Conntection:Keep-Alive 요청 헤더를 보내야함
- 커넥션을 계속 유지하려면 모든 메세지에 Conntection:Keep-Alive 헤더를 포함해야홤
- 클라이언트는 Conntection:Keep-Alive 응답 헤더가 없으면 서버가 응답 후에 커넥션을 끊을 것임을 알 수 있음
- 커넥션이 끊어지기 전에 엔터티의 본문의 길이를 알 수 있어야 커넥션을 유지할 수 있음(Content-Length 필수, 멀티파트 미디어 형식을 가지거나 청크 전송 인코딩으로 인코딩 되어야함)
- 프락시와 게이트웨이는 Conntection 헤더의 규칙을 철저히 지켜야 함

### 4.5.6 Keep-Alive와 dumb 프락시
- 프락시는 Conntection헤더와 여기에 명시된 헤더들은 절대 전달하면 안됨
- 프락시가 Conntection:Keep-Alive헤더를 받으면 Keep-Alive란 이름도 헤더의 전달하면 안됨
- 또한 Proxy-Connection 등 홉별 헤더들 역시 전달하거나 캐시하면 안됨

### 4.5.7 Proxy-Connection 살펴보기
- 멍청한 프락시 문제를 해결하기 위해 브라우저에서 일반적으로 전달하는 Connection 헤더 대신 비표준인 Proxy-Connection 확장 헤더를 프락시에 전달함
- 멍청한 프락시는 이것을 무시하지만, 영리한(지속 커넥션 핸드셰이킹을 할 수 있는) 프락시라면 의미없는 Proxy-Connection헤더를 Connection으로 바꿀 수 있음
- 이 방식은 클라이언트와 서버 사이에 한 개의 프락시만 있는 경우 동작함
- 멍청한 프락시를 포함하며 한 개 이상의 프락시가 있다면 문제가 발생함

### 4.5.8 HTTP/1.1 지속 커넥션
- HTTP/1.1에서는 Keep-Alive를 지원하지 않는 대신, 설계가 더 개선된 지속 커넥션을 지원함 (기본 설정)
- HTTP/1.1에서 커넥션을 끊으려면 Connection:close 헤더를 명시해야함

### 4.5.9 지속 커넥션의 제한과 규칙
- 클라이언트가 요청에 Connection: close 헤더를 포함해 보냈으면, 클라이언트는 그 커넥션으로 추가적인 요청을 보낼 수 없음
- 클라이언트가 해당 커넥션으로 추가적인 요청을 보내지 않을 것이라면, 마지막 요청에 Connection: close 헤더를 보내야 함
- 커넥션에 있는 모든 메시지가 자신의 길이 정보를 정확히 가지고 있을 때에만 커 넥션을 지속시킬 수 있음. 예를 들어 엔터티 본문은 정확한 Content-Length 값을 가지거나 청크 전송 인코딩(chunked transfer encoding)으로 인코드 되어 있어야함
- HTTP/1.1 프락시는 클라이언트와 서버 각각에 대해 별도의 지속 커넥션을 맺고 관리해야 함
- HTTP/1.1 프락시 서버는 클라이언트가 커넥션 관련 기능에 대한 클라이언트의 지원 범위를 알고 있지 않은 한 지속 커넥션을 맺으면 안됨(오래된 프락시가 Connection 헤더를 전달하는 문제가 발생할 수 있기 때문) 그러나 현실적으로 이것이 쉽지는 않으며, 많은 벤더가 이 규칙을 지키지 않음
- 서버는 메시지를 전송하는 중간에 커넥션을 끊지 않을 것이고 커넥션을 끊기 전에 적어도 한 개의 요청에 대해 응답을 할 것이긴 하지만, HTTP/1.1 기기는 Connetion 헤더의 값과는 상관없이 언제든지 커넥션을 끊을 수 있음
- HTTP/1.1 애플리케이션은 중간에 끊어지는 커넥션을 복구할 수 있어야만 함
- 클라이언트는 다시 보내도 문제가 없는 요청이라면 가능한 한 다시 보내야 함
- 클라이언트는 전체 응답을 받기 전에 커넥션이 끊어지면, 요청을 반복해서 보내 도 문제가 없는 경우에는 요청을 다시 보낼 준비가 되어 있어야 함
- 하나의 사용자 클라이언트는 서버의 과부하를 방지하기 위해서, 넉넉잡아 두 개의 지속 커넥션만을 유지해야 함

<br>

## 4.6 파이프라인 커넥션
- 파이프라인 커넥션: 공유 TCP 커넥션을 통한 병렬 HTTP 요청
- 파이프라인 제약 사항
    - HTTP 클라이언트는 커넥션이 지속 커넥션인지 확인하기 전까지는 파이프라인을 이어서는 안 됨
    - HTTP 응답은 요청 순서와 같게 와야 함(HTTP 메시지는 순번이 매겨져 있지 않아서 응답이 순서 없이 오면 순서에 맞게 정렬시킬 방법이 없음)
    - HTIP 클라이언트는 커넥션이 언제 끊어지더라도, 완료되지 않은 요청이 파이프 라인에 있으면 언제든 다시 요청을 보낼 준비가 되어 있어야 함
    - HTTP 클라이언트는 POST 요청같이 반복해서 보낼 경우 문제가 생기는 요청은 파이프라인을 통해 보내면 안 됨(에러가 발생하면 파이프라인을 통한 요청 중 에 어떤 것들이 서버에서 처리되었는지 클라이언트가 알 방법이 없음, POST와 같은 비덕등(nonidempotent) 요청을 재차 보내면 문제가 생길 수 있기 때문)

<br>

## 4.7 커넥션 끊기에 대한 미스터리
- 커넥션 관리(특히 언제 어떻게 커넥션을 끊는가)에는 명확하 기준이 없음

### 4.7.1 '마음대로' 커넥션 끊기
- 어떠한 클라이언트,서버, 혹은 프락시든 언제든지 TCP 전송 커넥션을 끊을 수 있음
- 에러가 있는 상황에서는 헤더의 중간이나 다른 엉뚱한 곳에서 끊길 수 있음 (ex: 파이프라인 지속 커넥션)

### 4.7.2 Content-Length와 Truncation(잘림)
- 각 HTIP 응답은 본문의 정확한 크기 값을 가지는 Content-Length 헤더를 가지고 있어야 함
-  일부 오래된 HTTP 서버는 자신이 커넥션을 끊으면 데이터 전송이 끝 났음을 의미하는 형태로 개발되어 있기 때문에, Content-Length 헤더를 생략하거 나 잘못된 길이 정보로 응답하는 경우도 있음

### 4.7.3 커넥션 끊기의 허용, 재시도, 멱등성
- 커넥션은 심지어 에러가 없더라도 언제든 끊을 수 있음
- HTTP 애플리케이션은 예상치 못하게 커넥션이 끊어졌을 때에 적절히 대응할 수 있는 준비가 되어 있어야 함
- 클라이언트가 트랜잭션을 수행 중에 전송 커넥션이 끊기게 되면, 클라이언트 는 그 트랜잭션을 재시도 하더라도 문제가 없다면 커넥션을 다시 맺고 한 번 더 전송을 시도해야 함
- 클라이언트는 여러 요청을 큐에 쌓아 놓을 수 있지만, 서버는 아직 처리되지 않고 스케줄이 조정되어야 하는 요청들을 남겨둔 채로 커넥션을 끊어버릴 수도 있어 이로인한 부작용들을 조심해야 함
- 한번 혹은 여러 번 실행됐는지에 상관없이 같은 결과를 반환한다면 그 트랜잭 션은 멱등(idempoient)하다고 함(GET, HEAD, PUT, DELETE, TRACE, OPTIONS)

### 4.7.4 우아한 커넥션 끊기
- 전체 끊기와 절반 끊기
    - 전체 끊기: TCP 커넥션의 입력 채널과 출력 채널의 커넥션을 모두 끊는 것 (`close()` 사용)
    - 절반 끊기: 입력 채널이나 출력 채널 중 하나를 개별적으로 끊는 것 (`shutdown()` 사용)
- TCP 끊기와 리셋 에러
    - 단순한 HITP 애플리케이션은 전체 끊기만을 사용할 수 있음
    -  하지만 애플리케이션이 각기 다른 HTTP 클라이언트, 서버, 프락시와 통신할 때, 그리고 그들과 파이프라인 지속 커넥션을 사용할 때, 기기들에 예상치 못한 쓰기 에러를 발생하는 것 을 예방하기 위해 '절반 끊기'를 사용해야 함
    - 보통은 커넥션의 출력 채널을 끊는 것이 안전함
    - 클라이언트에서 더는 데이터를 보내지 않을 것임을 확신할 수 없는 이상, 커넥션 의 입력 채널을 끊는 것은 위험함 
    - 만약 클라이언트에서 이미 끊긴 입력 채널에 데이터를 전송하면, 운영체제는 TCP 'connection reset by peer' 메시지를 클라이언트에 보낼 것. 
    - 대부분 운영체제는 이것을 심각한 에러로 취급하여 버퍼에 저장된, 아직 읽히지 않은 데이터를 모두 삭제하며 이러한 상황은 파이프라인 커넥션에서는 더 악화됨
- 우아하게 커넥션 끊기
    - 일반적으로 애플리케이션이 우아한 커넥션 끊기를 구현하는 것은 애플리케이션 자신의 출력 채널을 먼저 끊고 다른 쪽에 있는 기기의 출력 채널이 끊기는 것을 기다리는 것
    - 그러나 상대방이 절반 끊기를 구현했다는 보장도 없고 절반 끊기를 했는지 검사해준다는 보장도 없음 
    - 그래서 우아하게 커넥션 끊기를 하려면 출력 채널에 절반 끊기를 하고 난 후에도 데이터나 스트림의 끝을 식별하기 위해 입력 채널에 대해 상태 검사를 주기적으로 해야 함
