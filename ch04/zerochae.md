# 커넥션 관리

## 4.1 TCP 커넥션

- 모든 HTTP 통신은, TCP/IP를 통해 이루어진다.
- 커넥션이 맺어지면, 클라이언트와 서버 간에 주고받는 메시지들은 손실 되지 않고 안전하게 전달된다.

```text
http://www.some.page.com:80/index.html 요청 과정

1. 브라우저가 www.some.page.com 호스트 명 추출
2. 브라우저가 호스트에 대한 IP 주소 검색 --> 123.12.12.1
3. 브라우저가 포트 번호 (80)을 얻는다.
4. 123.12.12.1의 80포트로 TCP 커넥션 생성
5. 브라우저가 서버로 HTTP GET 요청 메시지 전송
6. 브라우저가 서버에서 온 HTTP 응답 메시지를 읽는다. 
7. 브라우저가 커넥션을 끊는다.
```

### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

- TCP 커넥션을 인터넷을 안정적으로 연결해준다.
- TCP 커넥션의 한쪽에 있는 바이트들은 반대쪽으로 순서에 맞게 정확히 전달된다.

### 4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다

- TCP는 IP패킷이라고 불리는 작은 조각을 통해 데이터를 전송한다.
- HTTP가 메시지를 전송하고자 할 경우, 현재 연결되어 있는 TCP 커넥션을 통해서 메시지 데이터의 내용을 순서대로 보낸다.
- TCP는 세그먼트라는 단위로 데이터 스트림을 작게 나누고, 세그먼트를 IP 패킷에 담아서 인터넷을 통해 데이터를 전송한다.
- TCP 세그먼트는 하나의 IP 주소에서 다른 IP주소로 IP 패킷에 담겨 전달된다.
  - IP 패킷 헤더(보통 20바이트)
  - TCP 세그먼트 헤더(보통 20바이트)
  - TCP 데이터 조각(0 혹은 그 이상의 바이트)
- IP 헤더는 발신자와 목적지 IP 주소, 크기, 기타 플래그를 가진다.

### 4.1.3 TCP 커넥션 유지하기

- 컴퓨터는 여러개의 TCP 커넥션을 가지고 있다.
- TCP는 포트 번호를 통해서 여러개의 커넥션을 유지한다.
- TCP 커넥션 = <발신 IP, 발신 포트, 수신 IP, 수신 포트>

### 4.1.4 TCP 소켓 프로그래밍

- TCP endpoint 생성하고, 서버의 TCP endpoint에 연결하여 데이터 스트림을 읽고 쓸 수 있다.

## 4.2 TCP의 성능에 대한 고려

- HTTP 트랜잭션의 성능은 그 아래 계층인 TCP 성능에 영향을 받는다.

### 4.2.1 HTTP 트랜잭션 지연

- 대부분의 HTTP 지연은 TCP 네트워크 지연 때문에 발생한다.
- 웹 서버 IP 주소, 포트 번호 해독 과정
- 서버에 많은 트랜잭션이 존재
- 요청 메시지가 서버에 의해 처리되는 시간
- 서버가 응답을 보내는 시간

### 4.2.2 성능 관련 중요 요소

- TCP 커넥션의 핸드쉐이크 설정
- TCP slow start
- nagle 알고리즘
- TCP piggyback 지연 알고리즘
- TIME_WAIT 지연과 포트 고갈

### 4.2.3 TCP 커넥션 핸드쉐이크 지연

- 클라이언트는 새로운 TCP 커넥션을 생성하기 위해 작은 TCP 패킷을 서버에 보낸다. --> SYN
- 서버가 커넥션을 받으면 매개변수를 산출하여, SYN, ACK를 포함한 TCP 패킷을 클라이언트에 보낸다
- 클라이언트는 서버에서 확인응답 신호를 보낸다.

### 4.2.4 확인응답 지연

- 인터넷 자체가 패킷 전송을 완벽히 보장하지는 않기 때문에, TCP는 성공 보장을 위해 자체적인 확인 체계를 가진다.
- 확인응답은 크기가 작기 때문에, TCP는 같은 방향으로 송출되는 데이터 패킷에 확인응답을 편승시킨다.
- 이 때, 경우의 수를 늘리기 위해 확인 응답 지연 알고리즘을 구현한다.
- 송출할 확인응답을 특정 시간 동안 버퍼에 저장해 두고, 확인응답을 편승시키기 위한 송출 데이터 패킷을 찾는다.
- 만약 일정 시간 안에 송출 데이터 패킷을 찾지 못하면 확인응답은 별도 패킷을 만들어 전송된다.

### 4.2.5 TCP 느린 시작(slow start)

- TCP의 데이터 전송 속도는 TCP 커넥션이 만들어진 지 얼마나 지났는지에 따라 달라질 수 있다.
- TCP 커넥션은 시간이 지나면서 자체적 튜닝을 한다.
- 처음에는 커넥션의 최대 속도를 제한하고, 데이터가 전송성공하면 속도 제한을 높여 간다.

### 4.2.6 네이클 알고리즘과 TCP_NODELAY

- 애플리케이션이 어떤 크기의 데이터든지 TCP 스택으로 전송할 수 있도록, TCP는 데이터 스트림 인터페이스를 제공한다.
- TCP가 많은 수의 패킷을 전송한다면 네트워크 성능은 크게 떨어진다.
- 이 때, 네트워크 전송 효율을 위해, TCP 데이터를 하나의 덩어리로 합친다.
- 세그먼트가 최대 크기가 되지 않으면 전송하지 않음.
- 하지만, 모든 패킷이 확인 응답을 받았을 경우에는 허락한다.
- HTTP 성능 관련 이슈가 있음 (작은 데이터는 무작정 기다려야함)
- 이 성능 향상을 위해 TCP+TCP_NODELAY 파라미터 값을 설정함

### 4.2.7 TIME_WAIT의 누적과 포트 고갈

- TCP 커넥션의 엔드포인트에서 커넥션을 종료하면, 종단에서는 커넥션의 IP 주소와 포트 번호를 메모리에 기록한다.
- 이 정보는 같은 주소와 같은 포트 일경우, 새로운 커넥션이 생성되지 않기 위함

## 4.3 HTTP 커넥션 관리

- HTTP 커넥션의 최적화

### 4.3.1 흔히 잘못 이해하는 Connection 헤더

- HTTP는 클라이언트의 서버 사이의 중개 서버를 허락한다.
- 이 중개서버에만 적용될 옵션을 지정해야할 때가 있다.
- Connection header 필드는 커넥션 토큰을 쉼표로 구분하여 가지고 있으며, 다른 커넥션에 전달되지 않는다.

### 4.3.2 순차적인 트랜잭션 처리에 의한 지연

- 커넥션 관리는 TCP 성능과 이어지는 문제이기 때문에, 아주 중요함
- 순차적인 처리로 인한 지연에는 물리적인 지연뿐만 아니라, 심리적인 지연도 포함함
- 모든 객체를 내려받기 전까지 텅 빈 화면을 보여준다.

### 4.4 병렬 커넥션

- 순차적인 트랜잭션 처리에서는 너무 느리기 때문에, 병렬로 처리하여 해결하려고함

### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다

- 단일 커넥션의 대역폭 제한과 커넥션이 동작하지 않고 있는 시간을 활용하면, 객체가 여러 개 있는 웹페이지를 더 빠르게 내려 받을 수 있다.
- 하나의 커넥션으로 객체들을 로드할 때의 대역폭 제한과 대기 시간을 줄일 수 있다면 더 빠르게 로드할 수 있다.
- 병렬적으로 처리하면 커넥션 지연이 겹쳐짐으로써 총 지연시간이 단축된다.

### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다

- 예를들어, 대역폭이 좁을 때는 대부분 시간을 데이터를 전송하는 데만 쓸 것이다.
- 이것을 병렬로 내려받으면, 제한된 대역폭 내에서 각 객체를 전송받는 것은 느리기 때문에 더 빠르다고 보장할 수 없다.
- 다수의 커넥션은 메모리를 많이 소모하고 자체적인 성능 문제를 발생한다.
- 백 명의 사용자가 100개의 커넥션을 맺고 있다면, 서버는 만개의 커넥션을 가지고 있기 때문에, 서버의 성능이 떨어진다.
- 그래서 브라우저는 적은 수의 병렬 커넥션만을 허용한다.

### 4.4.3 병렬 커넥션은 더 빠르게 느껴질 수 있다

- 화면에 여러 개의 객체가 동시에 보이면서 내려받고 있는 상황을 볼 수 있기 때문에
- 그래서 사용자는 더 빠르다고 느낌 (심리적 요소)
- 눈으로만 보이면 된다.

## 4.5 지속 커넥션

- 웹 클라이언트는 보통 같은 사이트에 여러 개의 커넥션을 맺느다.
- 이미지, 하이퍼링크 등등..
- 지역성(site locality): 같은 서버에 재 요청
- 처리가 완료된 이후에도 TCP 커넥션을 유지함. -> 지속 커넥션
- 맺어져 있는 커넥션을 재사용함으로, 커넥 맺기 위한 준비작업 시간을 절약할 수 있다.

### 4.5.1 지속 커넥션 vs 병렬 커넥션

- 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소요된다.
- 각각의 새로운 커넥션은 TCP 느린 시작 때문에 성능이 떨어진다.
- 실제로 연결할 수 있는 병렬 커넥션의 수에는 제한이 있다.
- 지속 커넥션은 사전 작업과 지연을 줄여진다.
- 튜닝된 커넥션을 유지한다.
- 커넥션의 수를 줄여준다.
- 그래서.. 같이 사용할 때 가장 효과적이다.
- 적은 수의 병렬 커넥션만을 맺고.. 그것을 유지한다.
- HTTP/1.0+ 에는 keep-alive 커넥션
- HTTP/1.1 에는 지속 커넥션이 있다.

### 4.5.2 HTTP/1.0+의 Keep-alive 커넥션

- 커넥션이 여러개인 경우.. 커넥션을 맺고 끊는데 필요한 작업이 없어서 시간이 단축된다.

### 4.5.3 Keep-alive 동작

- 근데 HTTP/1.1 에서 빠졌다.
- 하지만 아직도 브라우저와 서버 간에 keep-alive 핸드셰이크가 사용되고 있기 때문에, 그것을 처리할 수 있어야한다.
- Connection:Keep-Alive 헤더가 있으면 동작함
- 없으면.. 서버 커넥션을 끊을 것이라 추정한다.

```sh
GET /index.html HTTP/1.0
Host: www.page.com
Connection: Keep-Alive

HTTP/1.0 200 OK
Content-type: text/html
Content-length: 3104
Connection: Keep-Alive
```

### 4.5.4 Keep-Alive 옵션

- Keep-Alive는 커넥션을 유지하기를 바라는 요청일 뿐임.
- 서버나 클라이언트는 반드시 유지하지 않아도 된다. (끊을 수 있다.)

```sh
Connection: Keep-Alive
Keep-Alive: max=5, timeout=120
```

### 4.5.5 Keep-Alive 커넥션 제한과 규칙

- keep-alive는 HTTP/1.0에서 기본으로 사용되지 않는다. 클라이언트는 요청 헤더를 보내야한다.
- 커넥션을 계쏙 유지하려면 모든 메시지에 Connection:Keep-alive 헤더를 포함해야한다.
- 위 헤더가 없으면 서버는 요청을 처리 후 끊어버린다.
- 커넥션 유지를 위해서는 Content-length 헤더가 필요하다. 트랜잭션이 끝나는 시점에 메시지의 시작과 끝을 알 수 있기 때문

### 4.5.6 Keep-alive와 멍청한(dumb) 프록시

- 프록시는 Connection 헤더를 이해하지 못해서, 해당 헤더를 삭제하지 않고 그대로를 다음 프록시에 전달함
- Connection 헤더에 대한 처리 없이 요청을 그대로 전달한다.
- 프록시는 커넥션을 통해 들어오는 새 요청을 모두 무시하고, 커넥션이 끊어지기를 기다린다.
- 프록시가 기다리고 있기 때문에, 클라이언트의 두번째 요청은 처리되지 않는다.

### 4.5.7 Proxy -> Connection 살펴보기

- 위를 해결하기 위해 Proxy-Connection 이라는 헤더 사용
- 웹 서버는 이 헤더를 무시함

### 4.5.8 HTTP/1.1의 지속 커넥션

- HTTP/1.1에서는 keep-alive 커넥션을 지원하지 않는 대신, 개선된 지속커넥션을 지원한다.
- 기본값으로 설정되어 있음
- 모든 커넥션을 지속 커넥션으로 취급한다.
- 트랜잭션 종료 후, 커넥션을 끊으려면 Connection:close 를 명시해야함

### 4.5.9 지속 커넥션의 제한과 규칙

- Connection:close 헤더를 포함하면, 클라이언트는 그 커넥션으로 추가 요청을 할 수 없음
- 모든 메시지가 길이 정보를 정확히 가지고 있을 때, 커넥션을 지속할 수 있다.

## 4.6 파이프라인 커넥션

- 지속 커넥션을 통해 요청을 파이프라이닝할 수 있다.
- 이는 keep-alive 커넥션의 성능을 높여준다.
- 여러 요청이 도착하면, 큐에 쌓이고, 대기 시간이 긴 네트워크 상황에서 시간을 줄여서 성능을 높인다.
- HTTP 클라이언트는 커넥션이 지속 커넥션이 확인하기 전까지 파이프라인을 이어서는 안됨
- HTTP 응답은 요청 순서와 같게 와야 한다. HTTP 메시지는 순번이 없어서 순서 없이 오면 순서에 맞게 정렬할 수 없음
- HTTP 클라이언트는 POST 요청같은 메시지는 파이프라인을 통해 보내면 안됨
- 문제가 생기면 파이프라인을 통한 요청 중에 어떤 것이 서버에서 처리했는지 알 수 가 없기 때문

## 4.7 커넥션 끊기에 대한 미스터리

- 특별한 기준 없음

### 4.7.1 마음대로 커넥션 끊기

- 클라이언트, 프록시, 서버 모두 다 마음대로 끊을 수 있다.
- 보통은 메시지를 다 보낸 다음 끊는다.
- 에러 발생 시, 헤더의 중간이나 예측하지 못한 곳에서 끊길 수 있다.
- 이 상황은 파이프라인 지속 커넥션과 같다.
- 지속 커넥션이 일정 시간 동안 요청을 하지 않으면 끊을 수 있다.
- 근데 그 사이 요청이 들어온 다면.. 문제가 생김

### 4.7.2 Content-length와 Truncation

- 본문의 크기 값을 가지는 Content-length 헤더를 가지고 있어야함
- 클라이언트나 프록시가 커넥션이 끊어졌다는 응답을 받은 후, 실제 전달 된 엔티티의 길이와 Content-length의 값이 일치 하지 않거나
- Content-length 자체가 존재하지 않으면, 수신자는 데이터의 정확한 길이를 서버에게 물어봐야함

### 4.7.3 커넥션 끊기의 허용, 재시도, 멱등성

- 에러가 없어도 끊을 수 있다.
- 어플리케이션은 커넥션이 끊어졌을 경우의 대비를 해야한다.
- 트랜잭션 도중.. 연결이 끊어졌을 경우, 재시도 해도 문제가 없도록 해야함(다시 커넥션 맺고)
- 응답이 오기 전에 커넥션이 끊기면 클라이언트는 실제로 서버에서 어떤 요청이 처리된건지 알 수 없음
- POST 같은 경우.. 중복호출 문제가 있음
- 여러번 실행해도 같은 결과를 반환하면 그 트랙잭션은 멱등하다고 한다.
- GET, HEAD, PUT, DELETE, TRACE는 멱등하다
- POST와 같은 멱등이 아닌 요청은 파이프라인을 통해 요청하면 안 된다.
- 비멱등 요청을 다시 보내야 한다면.. 이전 요청에 대한 응답을 받을 때 까지 기다려야함

### 4.7.4 우아한 커넥션 끊기

- TCP 커넥션은 양방향이다.
- 양쪽에는 데이터를 읽고 쓰기 위한 입력 큐, 출력 큐가 있음
- 전체 끊기와 절반 끊기
  - 어플리케이션은 TCP 입력 채널과 출력 채널 중 한개만 끊거나 둘 다 끊을 수 있다.
  - close: 전체 끊기
  - shutdown: 절반 끊기
- TCP 끊기와 리셋 에러
  - 단순한 어플리케이션은 전체 끊기만을 사용할 수 있다.
  - 하지만 예상치 못한 에러가 발생했을 때, 쓰기 에러를 발생하는 것을 방지하기 위해 절반 끊기를 해야함
  - 보통은 커넥션의 출력 채널을 끊는 것이 안전
  - 커넥션의 반대편에 있는 기기는 모든 데이터를 버퍼로부터 읽고 나서 데이터 전송이 끝남과 동시에 커넥션이 끊김을 알 수 있다.
  - 클라이언트에서 더는 데이터를 보내지 않을 것임을 확신할 수 없는 이상, 커넥션의 입력 채널을 끊는 것은 위험하다.
  - 입력 채널이 끊겨있으면 TCP는 connection reset by peer 메시지를 클라이언트에 보낸다.
  - 이 때, 버퍼에 저장된, 아직 읽히지 않는 데이터를 모두 삭제한다. 이러면 더 악화됨
- 우아하게 커넥션 끊기
  - 클라이언트나 서버가 예기치 않게 커넥션을 끊어야 한다면, 우아하게 끊어라
  - 자신의 출구 채널을 먼저 끊고, 다른 쪽에 있는 기기의 출력 채널이 끊기는 것을 기다리는 것이다.
  - 양쪽에서 더는 데이터를 전송하지 않을 것이라 알려주면, 커넥션은 리셋의 위험 없이 종료된다.
  - 근데, 다른쪽에서 절반 끊기를 했는지 알 수 가 없으니.. 위의 처리 후에도 데이터나 스트림의 끝을 검사해야함
  - 입력 채널이 특정 타임아웃 시간에 끊어지지 않으면, 어플리케이션은 리소스 보호를 위해 커넥션을 강제로 끊을 수 있다.
