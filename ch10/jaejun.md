**HTTP 2.0 문제점**

- **RTT**
    - HTTP 1.1 이나 HTTP 2는 여전히 TCPVisit Website를 이용하기 때문에 Handshake의 RTT(Round Trip Time)로인한 지연 시간(Latency)이 발생한다. 결국 원초적으로 TCP로 통신하는게 문제다
- **HOLB**
    - TCP는 패킷이 유실되거나 오류가 있을때 재전송하는데, 이 재전송 과정에서 패킷의 지연이 발생하면 결국 HOLB 문제가 발생된다
- **중개자 캡슐화 공격**
    - HTTP 2.0 메시지를 중간의 Proxy 서버가 HTTP 1.1 메시지로 변환할 때 메시지를 불법 위조할수 있다는 위험성이 있다
- **길다란 커넥션 유지로 인한 개인정보 누출 우려**
    - HTTP 2.0은 기본적으로 성능을 위해 클라이언트와 서버 사이의 커넥션을 오래 유지하는 것을 염두에 두고 있다.
    

**HTTP 3.0**

HTTP는 TCP 기반 위에서 동작되기 때문에, TCP 자체의 핸드쉐이크 과정에서 발생하는 지연 시간과, 기본적으로 TCP는 패킷이 유실되거나 오류가 있을때 재전송을하는데 이 재전송하는 패킷에 지연이 발생하면 결국 HOLB(Head Of Line Blocking) 문제가 발생.

애초에 TCP로 인터넷 통신을 하는 것이 문제, 이런 고질적인 문제들을 해결하기 위해 HTTP/3는 TCP를 버리고 UDP를 선택하였다.  

구글은 SPDY 프로토콜에 이어 새로운 UDP 기반인 **QUIC** 프로토콜을 고안하게 된다. 그리고 이 새로운 **QUIC** 프로토콜이 TCP/IP 4계층에도 동작시키기 위해 설계된 것이 바로 **HTTP 3.0** 이다.

- RTT 문제해결
    - 핸드쉐이크 과정이 없음
- HOLB 문제해결
    - TCP를 버려버리고 새로 QUIC 프로토콜로 구축해서 아예 스트림 자체를 독립적으로 여러개로 나누어서 처리
- 패킷 손실에 대한 빠른 대응
    - 헤더에 패킷의 전송 순서를 나타내는 별도의 패킷 번호 공간을 부여 패킷 번호를 파악해 개별 파일을 구분하여 중간에 패킷 로스가 발생해도 해당 파일의 스트림만 정지가 되도록 할 수 있다.
- 사용자 IP가 바뀌어도 연결이 유지되는 것이 특징
    - Connection ID를 사용하여 서버와 연결을 생성한다

UDT는 데이터그램 방식을 사용하는 프로토콜이기 때문에 패킷의 목적지만 정해져있다면 중간 경로는 신경쓰지 않기 때문에 핸드쉐이크 과정이 필요없다

그렇다면 UDP를 사용하게되면 빠르지만 신뢰성과 패킷의 무결성을 보증할 없다는 뜻?

UDP는 신뢰성이 없는게 아니라 탑재를 안했을 뿐이다. UDT는 커스텀 마이징이 가능해서 개발자가 애플리케이션에서 구현을 어떻게 하냐에 따라서 TCP와 비슷한 수준의 기능을 가질 수도 있다

**HTTP3.0 문제점**

- 암호화로 네트워크 제어가 힘듬
    - 암호화하지 않던 헤더 필드도 암호화한다.
- 기존 체계 호환성 문제
- 암호화로 리소스가 많이 듬
    - QUIC은 패킷별로 암호화를 한다.
- QUIC는 CPU를 너무 사용함
- UDP의 보안적인 문제
    - UDP 트래픽이 최근에는 도스 공격에 주로 사용되기 때문에 많은 서비스들에서 차단하거나 속도를 제한하고 있다

[https://inpa.tistory.com/entry/WEB-🌐-HTTP-30-통신-기술-이제는-확실히-이해하자](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-HTTP-30-%ED%86%B5%EC%8B%A0-%EA%B8%B0%EC%88%A0-%EC%9D%B4%EC%A0%9C%EB%8A%94-%ED%99%95%EC%8B%A4%ED%9E%88-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90)