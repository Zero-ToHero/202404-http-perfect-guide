## HTTP 2.0의 등장배경

- 1.1은 구현의 단순성과 접근성에 중심을 둠
    - 성능이 희생됨 → 응답을 받아야 다음 요청을 보낼수 있음
    - 문제 해결을 위해 병렬 커넥션, 파이프라인 커넥션 등이 도입됐지만 해결 안됨
- 구글의 SPDY 프로토콜 등장
    - 하나의 TCP 커넥션에서 여러 요청을 동시에 보낼 수 있음
    - 서버 푸시 가능
    - SPDY를 기반으로 HTTP2.0 프로토콜을 설계하기로 함

## HTTP1.1과 차이점

### 프레임

- HTTP/2.0은 모든 메세지를 프레임에 담아 전송

### 스트림과 멀티 플렉싱

- 스트림 : HTTP2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스이다
- 한쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어진다
- 1.1 특징 : 하나의 TCP 커넥션을 통해 요청을 보냈을때 응답이 도착해야 같은 커넥션으로 다시 요청을 보낼 수 있음 → 그래서 보통 한번에 여러개의 TCP 커넥션을 만들어 동시에 여러개 요청을 보낸다
- 2.0 특징
    - 하나의 커넥션에서 여러개의 스트림이 동시에 열릴 수 있다 (멀티플렉싱)
    - 스트림은 우선순위를 가질 수 있다
    - 모든 스트림은 31비트의 무부호 정수로 된 고유한 식별자를 갖는다
    - 서버와 클라이언트는 협상 없이 스트림을 만듦
    - 한번 사용된 스트림 식별자는 다시 사용될 수 없음 → 식별자가 고갈될 때 커넥션 다시 맺으면됨
    - 동시에 여러개 스트림 이용하면 스트림이 블록될 우려가 있음

### 헤더 압축

- 1.1과 달리 헤더를 압축

### 서버 푸시

- 2.0에서는 서버는 클라이언트가 요청하기 전에 리소스를 클라이언트에 푸시할 수 있다
- 리소스를 푸시하려는 서버는 먼저 PUSH_PROMISE 프레임을 보내 푸시할 것임을 알려야한다 → 클라이언트는 RST_STREAM 프레임을 보내 푸시를 거절할 수 있다.

## 보안이슈

### 중개자 캡슐화 공격

- 헤더 필드로 어떤 문자열이든 허용 → HTTP 2.0 메시지를 중간의 프록시가 1.1로 변환할 때 메세지가 위조될 가능성이 있음

### 긴 커넥션 유지로 인한 개인정보 누출 우려

- 2.0은 1.1보다 훨씬 긴 커넥션을 유지한다. 어떤 사용자가 브라우저를 사용할 때 그 사용자는 이전에 브라우저를 사용했던 사용자가 무엇을 했는지 알아낼 가능성이 있음

## HTTP/3.0

- `HTTP/3` : TCP로 인해 발생되는 문제를 해결하기 위한 프로토콜, HTTP over QUIC (QUIC : TCP의 신뢰성 보장을 위해 제공되는 기능을 UDP 기반으로 직접 구현하여 성능을 개선한 프로토콜)
    - 기존 버전의 문제점 : TCP 프로토콜 자체의 병목 현상과 속도 문제
    - 특징 : **QUIC**이라는 프로토콜 위에서 동작, 연결 정보를 캐싱하여 재사용 (**0-RTT**, 연결 수립에 필요한 3-way 핸드셰이크 과정에 캐시를 이용), 연결 다중화를 지원하며 각 스트림이 완전히 독립적으로 동작, 연결 별 고유 UUID (Connection ID)를 이용해 각 연결을 식별.
